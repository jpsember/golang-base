package webserv

import (
	. "github.com/jpsember/golang-base/base"
)

type GridCell struct {
	Location IPoint
	Width    int
}

func (g *GridCell) String() string {
	m := NewJSMap()
	m.Put("", "GridCell")
	m.Put("Location", g.Location.String())
	m.Put("Width", g.Width)
	return m.AsString()
}

// A concrete Widget that can contain others
type ContainerWidgetObj struct {
	BaseWidgetObj
	children *Array[Widget]
	cells    *Array[GridCell]
	columns  int
}

type ContainerWidget = *ContainerWidgetObj

func NewContainerWidget(id string, m WidgetManager) ContainerWidget {
	w := ContainerWidgetObj{
		children: NewArray[Widget](),
		cells:    NewArray[GridCell](),
		columns:  m.pendingColumns,
	}
	w.Id = id
	return &w
}

func (w ContainerWidget) GetChildren() []Widget {
	return w.children.Array()
}

func (w ContainerWidget) AddChild(c Widget, manager WidgetManager) {
	w.children.Add(c)
	pr := PrIf(false)
	pr("adding widget to container:", INDENT, w)
	cell := GridCell{
		Width: manager.pendingColumns,
	}
	if w.cells.NonEmpty() {
		c := w.cells.Last()
		cell.Location = IPointWith(c.Location.X+c.Width, c.Location.Y)
	}
	if cell.Location.X+cell.Width > MaxColumns {
		cell.Location = IPointWith(0, cell.Location.Y+1)
		Todo("!add support for cell heights > 1")
	}
	w.cells.Add(cell)
}

func columnsTag(columns int) string {
	i := colorCounter
	colorCounter++
	return `div class="col-sm-` + IntToString(columns) + ` bg-` + colorsExpr[i%len(colorsExpr)] + `"`
}

var colorsExpr = []string{
	"primary",   //    $primary,
	"secondary", //  $secondary,
	"success",   //    $success,
	"info",      //       $info,
	"warning",   //    $warning,
	"danger",    //     $danger,
	"light",     //      $light,
	"dark",      //
}

var colorCounter int

func (w ContainerWidget) RenderTo(m MarkupBuilder, state JSMap) {
	m.Comments(false)
	desc := `ContainerWidget ` + w.IdSummary()
	m.OpenHtml(columnsTag(w.columns)+` id='`+w.Id+`'`, desc)
	if w.Visible() {
		prevPoint := IPointWith(0, -1)
		for index, child := range w.children.Array() {
			cell := w.cells.Get(index)
			// If this cell lies in a row below the current, Close the current and start a new one
			if cell.Location.Y > prevPoint.Y {
				if prevPoint.Y >= 0 {
					m.CloseHtml("div", "end of row")
				}
				m.Br()
				m.OpenHtml(`div class='row'`, `start of row`)
				m.Cr()
				prevPoint = IPointWith(0, cell.Location.Y)
			}

			// If cell lies to right of current, add space
			spaceColumns := cell.Location.X - prevPoint.X
			if spaceColumns > 0 {
				m.OpenHtml(columnsTag(spaceColumns), `spacer`)
				child.RenderTo(m, state)
				m.CloseHtml(`div`, `spacer`)
			}

			m.OpenHtml(columnsTag(cell.Width), `child`)
			child.RenderTo(m, state)
			m.CloseHtml(`div`, `child`)
			prevPoint = IPointWith(cell.Location.X+cell.Width, cell.Location.Y)
		}
		if prevPoint.Y >= 0 {
			m.CloseHtml("div", "row")
			m.Br()
		}
	}
	m.CloseHtml(`div`, desc)
	m.Comments(true)
}

func (w ContainerWidget) LayoutChildren(manager WidgetManager) {
	// We no longer need to do anything here, as the cells generated by AddChild() do most of the work
	pr := PrIf(false)
	pr("LayoutChildren:", INDENT, w)
}
